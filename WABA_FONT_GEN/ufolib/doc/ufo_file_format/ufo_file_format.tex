
\documentclass[a4paper]{article}
\usepackage{times}
\usepackage{t1enc}
\usepackage{url}

\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex}


% ----------------------------------------------------------------------------
\begin{document}


(C)2002, 2003 Oliver Erdmann

This document describes the ufo file format (UFF).

http://jdict.sf.net/ufolib

\hrulefill

\tableofcontents

\hrulefill

\section{Preface}

\subsection{Encoding}

The encoding system of UFF is \textbf{Unicode}.

\subsection{Naming the PDB}

The naming convention of ufo file format PDBs is:
\begin{quotation}
\verb+UFF+\textit{$<$name$>$}\textit{$<$psize$>$}\textit{$<$slant$>$}\\
\ \\
with\\
\ \ \textit{$<$name$>$} is the short name, e.g. "gnuuni", "myarial"\\
\ \ \textit{$<$psize$>$} is the point size, e.g. "10", "12"\\
\ \ \textit{$<$slant$>$} is "n" for normal font; "b", "i", "bi" for bold, italic, bold-italic.
\end{quotation}

The catalog's creator ID is "\verb+UFFo+", and the type is "\verb+DATA+". 

So, eg. the font "genXX" in point size 12, normal font, is named "\verb+UFFgenXX12n.pdb+" or "\verb+UFFgenXX12n.UFFo.DATA+" internally.

\section{The PDB format}

The UFF consists of one \emph{common part} and several \emph{range parts}.
Every part is a record in the PDB.

The font is divided in continuous encoding ranges. So, every range has a start
and end code, with no gaps in between. It might be required to divide code
ranges as of the maximum size of one PDB record (about 64k). It might be
useful to divide code ranges due to performance and memory reasons, because the
ranges will be loaded and cached separately. It might even be useful to
combine ranges (i.e. add dummy glyphs to get continuous range) to decrease the
number of ranges (if the glyph positions are very fragmented).


\subsection{Common Part}

It starts with:

\begin{verbatim}
   short magic;            // magic code: this is UFF
\end{verbatim}

and its currently 12003, witch encodes UFF and version of UFF. Then
the font characteristics 

\begin{verbatim}
   String fcName;          // is the short name, e.g. 
                           //   "gnuuni", "myarial"
   short fcSize;           // is the point size, e.g. 10, 12
   short fcSlant;          // is 0 for normal font; 1, 2, 3 
                           //   for bold, italic, bold-italic
\end{verbatim}

and

\begin{verbatim}
   String comment;         // comment
\end{verbatim}

where font description, comments, copyright notice etc. can be placed.

The following follows the header in a normal font PDB.

\begin{verbatim}
   short fontType;         // font type 0x9010
   short maxWidth;         // maximum character width
   short kernMax;          // negative of maximum character kern
   short nDescent;         // negative of descent
   short fRectWidth;       // width of font rectangle
   short fRectHeight;      // height of font rectangle
   short ascent;           // ascent
   short descent;          // descent
   short leading;          // leading
\end{verbatim}



Then, we need the information where to find the range parts:

\begin{verbatim}
   short nParts;           // number of parts following (without MCS)
\end{verbatim}

The next is coming nParts times:

\begin{verbatim}
   short recNo;            // record number, where is the range?
   int firstChar;          // encoding of first char in this range
   int lastChar;           // encoding of last char in this range
\end{verbatim}

Requirements: firstChar must be less or equal than lastChar, firstChar of the
next range in greater than lastChar.

Last is the entry for the unknown char (MCS), this is a small range ;-).
\begin{verbatim}
   short recNo;            // record number, where to find this char
\end{verbatim}


\subsection{Range Part}

One range part contains the bitmaps for one contiguous encoding range of chars.

First the pixel data:
\begin{verbatim}
   int rowByte;            // row width in bytes
\end{verbatim}
the row size in bytes, and
\begin{verbatim}
   byte[] bitmapTable;   // the glyph pixel data
\end{verbatim}

its size is fRectHeight $\times$ rowByte.

Then, the bitmap location table, so:
\begin{verbatim}
   int[] bitIndexTable;   // where to find one char in the bitmap soup
\end{verbatim}

as standard, one more entry than chars (without the MCS), because the last
entry of the table contains the offset to one bit beyond the end of the bit
image.


\subsection{PDB records}

So, resulting PDB records are:

\begin{tabular}{|l|l|}
RecNo & Description \\ \hline\hline
0 & Common Part \\ \hline
1 \ldots n & ranges \\ \hline
n+1 & MCS range \\ \hline
\end{tabular}

\section{Resources}

\begin{itemize}
\item PalmOS Font Structure, \url{http://www.symbioforge.com/fe/}
\item In SuperWaba: \verb+waba.applet.UserFont.java+.
\item Unicode: \url{http://www.unicode.org}
\end{itemize}

\end{document}













